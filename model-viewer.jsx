import React, { useRef, useEffect, useState, useCallback } from 'react';
import * as THREE from 'three';
import { Maximize2, Minimize2, RotateCcw, ZoomIn, ZoomOut, Move, Download, Layers, Box, Scaling } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Slider } from '@/components/ui/slider';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";

// Build 3D model from JSON structure
const buildModelFromData = (modelData, material) => {
  const group = new THREE.Group();
  
  if (!modelData || !modelData.parts) return group;
  
  modelData.parts.forEach(part => {
    let geometry;
    
    switch (part.type) {
      case 'box':
        geometry = new THREE.BoxGeometry(
          part.width || 1, 
          part.height || 1, 
          part.depth || 1
        );
        break;
      case 'cylinder':
        geometry = new THREE.CylinderGeometry(
          part.radiusTop || 0.5,
          part.radiusBottom || 0.5,
          part.height || 1,
          part.segments || 16
        );
        break;
      case 'sphere':
        geometry = new THREE.SphereGeometry(
          part.radius || 0.5,
          part.widthSegments || 16,
          part.heightSegments || 16
        );
        break;
      case 'cone':
        geometry = new THREE.ConeGeometry(
          part.radius || 0.5,
          part.height || 1,
          part.segments || 16
        );
        break;
      case 'torus':
        geometry = new THREE.TorusGeometry(
          part.radius || 0.5,
          part.tube || 0.2,
          part.radialSegments || 8,
          part.tubularSegments || 24
        );
        break;
      default:
        geometry = new THREE.BoxGeometry(1, 1, 1);
    }
    
    const partMaterial = part.color 
      ? new THREE.MeshStandardMaterial({ 
          color: part.color, 
          metalness: 0.3, 
          roughness: 0.7 
        })
      : material.clone();
    
    const mesh = new THREE.Mesh(geometry, partMaterial);
    
    if (part.position) {
      mesh.position.set(part.position.x || 0, part.position.y || 0, part.position.z || 0);
    }
    if (part.rotation) {
      mesh.rotation.set(
        (part.rotation.x || 0) * Math.PI / 180,
        (part.rotation.y || 0) * Math.PI / 180,
        (part.rotation.z || 0) * Math.PI / 180
      );
    }
    if (part.scale) {
      mesh.scale.set(part.scale.x || 1, part.scale.y || 1, part.scale.z || 1);
    }
    
    if (part.name) mesh.name = part.name;
    group.add(mesh);
  });
  
  // Center the model
  const box = new THREE.Box3().setFromObject(group);
  const center = box.getCenter(new THREE.Vector3());
  group.position.sub(center);
  
  return group;
};

// Export to OBJ format
const exportToOBJ = (model, name) => {
  let objContent = `# OBJ file generated by JARVIS\n# Model: ${name}\n\n`;
  let vertexOffset = 0;
  
  model.traverse((child) => {
    if (child.isMesh && child.geometry) {
      const geometry = child.geometry;
      const position = geometry.attributes.position;
      
      objContent += `o ${child.name || 'part'}\n`;
      
      for (let i = 0; i < position.count; i++) {
        const x = position.getX(i) + child.position.x;
        const y = position.getY(i) + child.position.y;
        const z = position.getZ(i) + child.position.z;
        objContent += `v ${x.toFixed(4)} ${y.toFixed(4)} ${z.toFixed(4)}\n`;
      }
      
      const index = geometry.index;
      if (index) {
        for (let i = 0; i < index.count; i += 3) {
          objContent += `f ${index.getX(i) + 1 + vertexOffset} ${index.getX(i + 1) + 1 + vertexOffset} ${index.getX(i + 2) + 1 + vertexOffset}\n`;
        }
      } else {
        for (let i = 0; i < position.count; i += 3) {
          objContent += `f ${i + 1 + vertexOffset} ${i + 2 + vertexOffset} ${i + 3 + vertexOffset}\n`;
        }
      }
      
      vertexOffset += position.count;
    }
  });
  
  return objContent;
};

// Export to GLTF JSON format
const exportToGLTF = (modelData) => {
  const gltf = {
    asset: { version: "2.0", generator: "JARVIS 3D Export" },
    scene: 0,
    scenes: [{ nodes: [0] }],
    nodes: [{ 
      name: modelData.name,
      children: modelData.parts.map((_, i) => i + 1)
    }],
    meshes: [],
    accessors: [],
    bufferViews: [],
    buffers: []
  };
  
  modelData.parts.forEach((part, i) => {
    gltf.nodes.push({
      name: part.name || `part_${i}`,
      mesh: i,
      translation: part.position ? [part.position.x || 0, part.position.y || 0, part.position.z || 0] : [0, 0, 0]
    });
    gltf.meshes.push({
      name: part.name || `mesh_${i}`,
      primitives: [{ attributes: { POSITION: i }, mode: 4 }]
    });
  });
  
  return JSON.stringify(gltf, null, 2);
};

// Download helper
const downloadFile = (content, filename, mimeType) => {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
};

export default function ModelViewer({ modelData, isExpanded, onToggleExpand }) {
  const containerRef = useRef(null);
  const rendererRef = useRef(null);
  const sceneRef = useRef(null);
  const cameraRef = useRef(null);
  const modelRef = useRef(null);
  const originalPositionsRef = useRef([]);
  const controlsRef = useRef({ 
    isDragging: false, 
    previousMouse: { x: 0, y: 0 },
    rotation: { x: 0, y: 0 },
    zoom: 3
  });
  const frameRef = useRef(null);
  const [isInitialized, setIsInitialized] = useState(false);
  const [autoRotate, setAutoRotate] = useState(true);
  const [explodedView, setExplodedView] = useState(false);
  const [explodeAmount, setExplodeAmount] = useState(0);
  const [modelScale, setModelScale] = useState(1);
  const [showManipulation, setShowManipulation] = useState(false);

  // Initialize scene
  useEffect(() => {
    if (!containerRef.current || isInitialized) return;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a0f);
    sceneRef.current = scene;

    // Add grid
    const grid = new THREE.GridHelper(4, 20, 0x00d4ff, 0x1a1a2e);
    grid.position.y = -1;
    scene.add(grid);

    // Add lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);
    
    const pointLight = new THREE.PointLight(0x00d4ff, 0.5);
    pointLight.position.set(-3, 3, -3);
    scene.add(pointLight);

    // Camera
    const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);
    camera.position.z = 3;
    cameraRef.current = camera;

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    containerRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;

    setIsInitialized(true);

    return () => {
      if (frameRef.current) cancelAnimationFrame(frameRef.current);
      if (rendererRef.current && containerRef.current) {
        containerRef.current.removeChild(rendererRef.current.domElement);
        rendererRef.current.dispose();
      }
    };
  }, []);

  // Handle resize
  useEffect(() => {
    if (!isInitialized || !containerRef.current || !rendererRef.current || !cameraRef.current) return;
    
    const updateSize = () => {
      const width = containerRef.current.clientWidth;
      const height = containerRef.current.clientHeight;
      rendererRef.current.setSize(width, height);
      cameraRef.current.aspect = width / height;
      cameraRef.current.updateProjectionMatrix();
    };
    
    updateSize();
    window.addEventListener('resize', updateSize);
    return () => window.removeEventListener('resize', updateSize);
  }, [isInitialized, isExpanded]);

  // Build model when data changes
  useEffect(() => {
    if (!isInitialized || !sceneRef.current || !modelData) return;

    // Remove old model
    if (modelRef.current) {
      sceneRef.current.remove(modelRef.current);
      modelRef.current.traverse((child) => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      });
    }

    // Create new model
    const material = new THREE.MeshStandardMaterial({ 
      color: 0x00d4ff, 
      metalness: 0.4, 
      roughness: 0.6 
    });
    
    const model = buildModelFromData(modelData, material);
    sceneRef.current.add(model);
    modelRef.current = model;
    
    // Store original positions for exploded view
    const positions = [];
    model.traverse((child) => {
      if (child.isMesh) {
        positions.push({
          mesh: child,
          original: child.position.clone(),
          direction: child.position.clone().normalize()
        });
      }
    });
    originalPositionsRef.current = positions;
    
    // Reset controls
    controlsRef.current.rotation = { x: 0, y: 0 };
    controlsRef.current.zoom = 3;
    setExplodeAmount(0);
    setExplodedView(false);
    setModelScale(1);

  }, [isInitialized, modelData]);

  // Handle exploded view
  useEffect(() => {
    if (!modelRef.current || originalPositionsRef.current.length === 0) return;
    
    originalPositionsRef.current.forEach(({ mesh, original, direction }) => {
      if (explodedView && explodeAmount > 0) {
        const offset = direction.clone().multiplyScalar(explodeAmount * 2);
        mesh.position.copy(original.clone().add(offset));
      } else {
        mesh.position.copy(original);
      }
    });
  }, [explodedView, explodeAmount]);

  // Handle scale
  useEffect(() => {
    if (modelRef.current) {
      modelRef.current.scale.setScalar(modelScale);
    }
  }, [modelScale]);

  // Animation loop
  useEffect(() => {
    if (!isInitialized) return;

    const animate = () => {
      frameRef.current = requestAnimationFrame(animate);

      if (modelRef.current) {
        if (autoRotate && !controlsRef.current.isDragging) {
          controlsRef.current.rotation.y += 0.005;
        }
        modelRef.current.rotation.x = controlsRef.current.rotation.x;
        modelRef.current.rotation.y = controlsRef.current.rotation.y;
      }

      if (cameraRef.current) {
        cameraRef.current.position.z = controlsRef.current.zoom;
      }

      if (rendererRef.current && sceneRef.current && cameraRef.current) {
        rendererRef.current.render(sceneRef.current, cameraRef.current);
      }
    };

    animate();
    return () => { if (frameRef.current) cancelAnimationFrame(frameRef.current); };
  }, [isInitialized, autoRotate]);

  // Mouse controls
  const handleMouseDown = useCallback((e) => {
    controlsRef.current.isDragging = true;
    controlsRef.current.previousMouse = { x: e.clientX, y: e.clientY };
  }, []);

  const handleMouseMove = useCallback((e) => {
    if (!controlsRef.current.isDragging) return;
    
    const deltaX = e.clientX - controlsRef.current.previousMouse.x;
    const deltaY = e.clientY - controlsRef.current.previousMouse.y;
    
    controlsRef.current.rotation.y += deltaX * 0.01;
    controlsRef.current.rotation.x += deltaY * 0.01;
    controlsRef.current.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, controlsRef.current.rotation.x));
    
    controlsRef.current.previousMouse = { x: e.clientX, y: e.clientY };
  }, []);

  const handleMouseUp = useCallback(() => {
    controlsRef.current.isDragging = false;
  }, []);

  const handleWheel = useCallback((e) => {
    e.preventDefault();
    controlsRef.current.zoom += e.deltaY * 0.01;
    controlsRef.current.zoom = Math.max(1.5, Math.min(8, controlsRef.current.zoom));
  }, []);

  const handleZoomIn = () => {
    controlsRef.current.zoom = Math.max(1.5, controlsRef.current.zoom - 0.5);
  };

  const handleZoomOut = () => {
    controlsRef.current.zoom = Math.min(8, controlsRef.current.zoom + 0.5);
  };

  const handleReset = () => {
    controlsRef.current.rotation = { x: 0, y: 0 };
    controlsRef.current.zoom = 3;
    setExplodeAmount(0);
    setExplodedView(false);
    setModelScale(1);
  };

  const handleExportOBJ = () => {
    if (!modelRef.current) return;
    const obj = exportToOBJ(modelRef.current, modelData.name || 'model');
    downloadFile(obj, `${modelData.name || 'model'}.obj`, 'text/plain');
  };

  const handleExportGLTF = () => {
    if (!modelData) return;
    const gltf = exportToGLTF(modelData);
    downloadFile(gltf, `${modelData.name || 'model'}.gltf`, 'application/json');
  };

  const handleExportJSON = () => {
    if (!modelData) return;
    downloadFile(JSON.stringify(modelData, null, 2), `${modelData.name || 'model'}.json`, 'application/json');
  };

  if (!modelData) return null;

  return (
    <div className={`bg-gray-900 rounded-xl border border-cyan-500/30 overflow-hidden transition-all ${
      isExpanded ? 'fixed inset-4 z-50' : 'relative'
    }`}>
      {/* Header */}
      <div className="flex items-center justify-between px-4 py-2 bg-gray-900/90 border-b border-cyan-500/30">
        <div className="flex items-center gap-2">
          <div className="w-2 h-2 rounded-full bg-cyan-500 animate-pulse" />
          <span className="text-xs font-mono text-cyan-400 uppercase">
            3D Model: {modelData.name || 'Generated Model'}
          </span>
        </div>
        <div className="flex items-center gap-1">
          <Button 
            variant="ghost" size="sm" 
            onClick={() => setShowManipulation(!showManipulation)} 
            className={`p-1 h-7 w-7 ${showManipulation ? 'text-cyan-400' : 'text-gray-400 hover:text-cyan-400'}`}
          >
            <Scaling className="w-3 h-3" />
          </Button>
          <Button 
            variant="ghost" size="sm" 
            onClick={() => setExplodedView(!explodedView)} 
            className={`p-1 h-7 w-7 ${explodedView ? 'text-cyan-400' : 'text-gray-400 hover:text-cyan-400'}`}
          >
            <Layers className="w-3 h-3" />
          </Button>
          <Button variant="ghost" size="sm" onClick={handleReset} className="text-gray-400 hover:text-cyan-400 p-1 h-7 w-7">
            <RotateCcw className="w-3 h-3" />
          </Button>
          <Button variant="ghost" size="sm" onClick={handleZoomIn} className="text-gray-400 hover:text-cyan-400 p-1 h-7 w-7">
            <ZoomIn className="w-3 h-3" />
          </Button>
          <Button variant="ghost" size="sm" onClick={handleZoomOut} className="text-gray-400 hover:text-cyan-400 p-1 h-7 w-7">
            <ZoomOut className="w-3 h-3" />
          </Button>
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="ghost" size="sm" className="text-gray-400 hover:text-cyan-400 p-1 h-7 w-7">
                <Download className="w-3 h-3" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent className="bg-gray-900 border-cyan-500/30">
              <DropdownMenuItem onClick={handleExportOBJ} className="text-gray-300 hover:text-cyan-400 cursor-pointer">
                Export OBJ
              </DropdownMenuItem>
              <DropdownMenuItem onClick={handleExportGLTF} className="text-gray-300 hover:text-cyan-400 cursor-pointer">
                Export GLTF
              </DropdownMenuItem>
              <DropdownMenuItem onClick={handleExportJSON} className="text-gray-300 hover:text-cyan-400 cursor-pointer">
                Export JSON
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
          <Button variant="ghost" size="sm" onClick={onToggleExpand} className="text-gray-400 hover:text-cyan-400 p-1 h-7 w-7">
            {isExpanded ? <Minimize2 className="w-3 h-3" /> : <Maximize2 className="w-3 h-3" />}
          </Button>
        </div>
      </div>

      {/* Manipulation Panel */}
      {showManipulation && (
        <div className="px-4 py-3 bg-gray-800/50 border-b border-cyan-500/20 space-y-3">
          <div className="flex items-center gap-3">
            <span className="text-xs text-gray-400 w-12">Scale</span>
            <Slider
              value={[modelScale]}
              onValueChange={(v) => setModelScale(v[0])}
              min={0.5}
              max={2}
              step={0.1}
              className="flex-1"
            />
            <span className="text-xs text-cyan-400 w-10">{modelScale.toFixed(1)}x</span>
          </div>
          {explodedView && (
            <div className="flex items-center gap-3">
              <span className="text-xs text-gray-400 w-12">Explode</span>
              <Slider
                value={[explodeAmount]}
                onValueChange={(v) => setExplodeAmount(v[0])}
                min={0}
                max={1}
                step={0.05}
                className="flex-1"
              />
              <span className="text-xs text-cyan-400 w-10">{Math.round(explodeAmount * 100)}%</span>
            </div>
          )}
        </div>
      )}

      {/* Viewer */}
      <div 
        ref={containerRef}
        className={`${isExpanded ? 'h-[calc(100%-80px)]' : 'h-64'} cursor-grab active:cursor-grabbing`}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
        onWheel={handleWheel}
      />
      
      {/* Exploded View Label */}
      {explodedView && (
        <div className="absolute top-12 left-4 px-2 py-1 bg-cyan-500/20 border border-cyan-500/50 rounded text-xs text-cyan-400 font-mono">
          EXPLODED VIEW
        </div>
      )}

      {/* Footer */}
      <div className="flex items-center justify-between px-4 py-2 bg-gray-900/90 border-t border-cyan-500/30">
        <span className="text-xs text-gray-500 font-mono">
          {modelData.parts?.length || 0} parts
        </span>
        <div className="flex items-center gap-2">
          <Move className="w-3 h-3 text-gray-500" />
          <span className="text-xs text-gray-500 font-mono">Drag to rotate â€¢ Scroll to zoom</span>
        </div>
        <button 
          onClick={() => setAutoRotate(!autoRotate)}
          className={`text-xs font-mono ${autoRotate ? 'text-cyan-400' : 'text-gray-500'}`}
        >
          Auto-rotate: {autoRotate ? 'ON' : 'OFF'}
        </button>
      </div>
    </div>
  );
}
